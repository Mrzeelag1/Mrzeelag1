<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Zeelag Transform</title>
<style>
body { margin:0; overflow:hidden; background:black; }
</style>
</head>

<body>

<script type="module">

import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";
import { FontLoader } from "https://unpkg.com/three@0.158.0/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "https://unpkg.com/three@0.158.0/examples/jsm/geometries/TextGeometry.js";

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 10, 80);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,2,18);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// lights
scene.add(new THREE.AmbientLight(0x222244));

const p1 = new THREE.PointLight(0x00ffff, 2);
p1.position.set(10,10,10);
scene.add(p1);

const p2 = new THREE.PointLight(0x0088ff, 2);
p2.position.set(-10,-5,10);
scene.add(p2);

// grid
const grid = new THREE.GridHelper(60,60,0x00ffff,0x003333);
grid.position.y = -4;
scene.add(grid);

let zMesh;
let letters = [];
let phase = 0;
let reveal = 0;

const loader = new FontLoader();

loader.load(
"https://threejs.org/examples/fonts/helvetiker_bold.typeface.json",
font => {

  const mat = new THREE.MeshStandardMaterial({
    color:0x00e5ff,
    metalness:1,
    roughness:.2,
    emissive:0x003344
  });

  // Z
  const zGeo = new TextGeometry("Z", {
    font: font,
    size: 5,
    height: 1,
    bevelEnabled:true,
    bevelSize:.08,
    bevelThickness:.1
  });
  zGeo.center();
  zMesh = new THREE.Mesh(zGeo, mat);
  scene.add(zMesh);

  // ZEELAG letters
  const word = "ZEELAG";
  for(let i=0;i<word.length;i++){
    const g = new TextGeometry(word[i], {
      font: font,
      size: 2.2,
      height: .6,
      bevelEnabled:true,
      bevelSize:.04,
      bevelThickness:.05
    });
    g.center();

    const m = new THREE.Mesh(g, mat.clone());
    m.position.x = (i - word.length/2) * 3 + 1.5;
    m.position.y = -1;
    m.scale.set(0,0,0);
    m.visible = false;
    scene.add(m);
    letters.push(m);
  }
});

const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  if(zMesh){

    // robotic rotation
    zMesh.rotation.y += 0.02;
    zMesh.rotation.x = Math.sin(t*3)*0.1;

    if(phase === 0){
      const s = 1 + Math.sin(t*8)*0.15;
      zMesh.scale.set(s,s,s);
      if(t > 2) phase = 1;
    }

    if(phase === 1){
      zMesh.scale.multiplyScalar(0.94);
      zMesh.rotation.z += 0.15;
      if(zMesh.scale.x < 0.15){
        zMesh.visible = false;
        phase = 2;
      }
    }
  }

  // reveal ZEELAG
  if(phase === 2 && reveal < letters.length){
    const m = letters[reveal];
    m.visible = true;
    m.scale.lerp(new THREE.Vector3(1,1,1), 0.25);
    m.rotation.y += 0.25;
    if(m.scale.x > .95) reveal++;
  }

  letters.forEach((m,i)=>{
    if(m.visible){
      m.rotation.y += 0.01;
      m.position.y += Math.sin(t*4+i)*0.01;
    }
  });

  camera.position.x = Math.sin(t*.4)*4;
  camera.lookAt(0,0,0);

  renderer.render(scene,camera);
}

animate();

window.onresize = () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};

</script>
</body>
</html>
      revealIndex++;
    }
  }

  // continuous robotic motion on letters
  wordMeshes.forEach((m,i)=>{
    if(m.visible){
      m.rotation.y += 0.01;
      m.position.y += Math.sin(t*4 + i)*0.01;
    }
  });

  // camera drift
  camera.position.x = Math.sin(t*0.4)*4;
  camera.lookAt(0,0,0);

  renderer.render(scene, camera);
}

animate();

onresize = () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
</script>

</body>
</html>